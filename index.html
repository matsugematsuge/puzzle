<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>宝石パズルゲーム</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<style>
  * {
    touch-action: none !important;
    user-select: none;
    -webkit-user-select: none;
    -webkit-touch-callout: none;
    box-sizing: border-box;
  }
  body {
    margin: 0;
    padding: 0;
    height: 100dvh;
    background: linear-gradient(135deg, #0f001a, #1a0033);
    color: #eee;
    font-family: system-ui, sans-serif;
    overflow: hidden;
    display: flex;
    flex-direction: column;
    align-items: center;
  }
  #container {
    width: 100%;
    max-width: 480px;
    padding: 5px 5px 0;
    flex: 1;
    display: flex;
    flex-direction: column;
    justify-content: flex-start;
  }
  #top-bar {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 5px;
  }
  #norma {
    display: flex;
    gap: 6px;
  }
  .norma-item {
    background: rgba(40,20,80,0.7);
    border: 2px solid #6644aa;
    border-radius: 10px;
    padding: 5px 8px;
    text-align: center;
    min-width: 60px;
    height: 35px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0.75rem;
    font-weight: bold;
  }
  .norma-green { color: #66ff99; text-shadow: 0 0 5px #66ff99; }
  .norma-pink  { color: #ff99dd; text-shadow: 0 0 5px #ff99dd; }
  .norma-yellow{ color: #ffff88; text-shadow: 0 0 5px #ffff88; }

  #reset-btn {
    background: rgba(40,20,80,0.7);
    border: 2px solid #6644aa;
    border-radius: 10px;
    width: 35px;
    height: 35px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1.1rem;
    color: #aaa;
    cursor: pointer;
    transition: background 0.3s;
  }
  #reset-btn:hover { background: rgba(100,50,200,0.5); }

  #board-container {
    background: #0a0a1a;
    border: 6px solid #443366;
    border-radius: 0;
    padding: 4px;
    box-shadow: 0 5px 20px rgba(0,0,0,0.6);
    position: relative;
    flex: 1;
    max-height: 58vh;
    aspect-ratio: 1 / 1;
    width: 100%;
  }
  #board {
    height: 100%;
    width: 100%;
    display: grid;
    grid-template-columns: repeat(8, 45px); /* 45px固定 */
    grid-template-rows: repeat(8, 45px); /* 45px固定 */
    gap: 2px;
    background: rgba(0,0,0,0.4);
    border-radius: 0;
    overflow: hidden;
    margin: 0 auto;
  }
  .cell {
    background: #1a1a2e;
    border-radius: 0;
    transition: all 0.4s ease;
    position: relative;
    width: 45px;
    height: 45px;
  }
  .cell.filled { box-shadow: inset 0 0 8px #000; }
  .color-1 { background: #a0a0b0; }
  .color-2 { background: #66ff99; }
  .color-3 { background: #ff99dd; }
  .color-4 { background: #ffff88; }

  .clearing {
    animation: clearAnim 0.6s ease forwards;
  }
  @keyframes clearAnim {
    0%   { opacity: 1; transform: scale(1); }
    50%  { opacity: 0.6; transform: scale(1.15); }
    100% { opacity: 0; transform: scale(0.6); }
  }

  .preview {
    position: absolute;
    inset: 0;
    border-radius: 0;
    opacity: 0.35;
    pointer-events: none;
    z-index: 10;
  }

  #hand {
    margin: 5px 0;
    display: flex;
    justify-content: center;
    gap: 6px;
    flex-wrap: wrap;
  }
  .piece {
    padding: 0;
    border: none;
    background: transparent;
    cursor: grab;
    touch-action: none;
  }
  .piece-grid {
    display: inline-grid;
    gap: 2px;
    box-shadow: 0 3px 10px rgba(0,0,0,0.4);
    border-radius: 0;
    background: rgba(60,40,100,0.3);
    padding: 0;
  }
  .piece-cell {
    width: 45px;
    height: 45px;
    border-radius: 0;
  }

  .gameover, .clear-screen {
    position: absolute;
    inset: 0;
    background: rgba(0,0,0,0.85);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    color: #fff;
    font-size: 2rem;
    font-weight: bold;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.6s;
  }
  .gameover.show, .clear-screen.show { opacity: 1; pointer-events: all; }

  .restart-btn {
    margin-top: 10px;
    padding: 8px 20px;
    font-size: 1rem;
    background: #6644aa;
    color: white;
    border: none;
    border-radius: 10px;
    cursor: pointer;
    transition: background 0.3s;
  }
  .restart-btn:hover { background: #8866cc; }

  #move-counter {
    margin: 5px 0;
    font-size: 0.9rem;
    color: #aaa;
  }
</style>
</head>
<body>

<div id="container">
  <div id="top-bar">
    <div id="move-counter">操作回数: <span id="moveCount">0</span></div>
    <div id="norma">
      <div class="norma-item norma-green">♥ <span id="c2">0/5</span></div>
      <div class="norma-item norma-pink">♥ <span id="c3">0/5</span></div>
      <div class="norma-item norma-yellow">♥ <span id="c4">0/5</span></div>
    </div>
    <button id="resetBtn" class="restart-btn">↻</button>
  </div>

  <div id="board-container">
    <div id="board"></div>
    <div class="gameover" id="gameover">GAME OVER<br><small>タップで再スタート</small></div>
    <div class="clear-screen" id="clearScreen">
      クリア！<br>
      <div id="clearMoves"></div>
      <button class="restart-btn" id="restartBtn">もう一度あそぶ</button>
    </div>
  </div>

  <div id="hand"></div>
</div>

<script>
// 省略せず完全コードを記述（ロジックは前回と同じ）
const SIZE = 8;
const TARGET = 5;
const NORMA_COLORS = [2,3,4];

const SHAPES = [
  [[0,0],[1,0],[2,0],[2,1]],
  [[0,0],[0,1],[0,2],[1,2]],
  [[0,0],[0,1]],
  [[0,0],[0,1],[0,2],[0,3]],
  [[0,0],[0,1],[1,0],[1,1]],
  [[0,0],[0,1],[0,2],[1,1]],
  [[1,0],[1,1],[1,2],[0,1]],
  [[0,0],[1,0],[2,0],[1,1]]
];

let board = Array(SIZE).fill().map(()=>Array(SIZE).fill(0));
let hand = [];
let cleared = new Set();
let counts = {2:0, 3:0, 4:0};
let gameOver = false;
let currentDragPiece = null;
let currentPreviewCells = [];
let dragOffset = { dx: 0, dy: 0 };
let moveCount = 0;
let isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;

const boardEl = document.getElementById('board');
const handEl = document.getElementById('hand');
const gameoverEl = document.getElementById('gameover');
const clearScreen = document.getElementById('clearScreen');
const clearMoves = document.getElementById('clearMoves');
const restartBtn = document.getElementById('restartBtn');
const resetBtn = document.getElementById('resetBtn');
const moveCountEl = document.getElementById('moveCount');

function init() {
  boardEl.innerHTML = '';
  board = Array(SIZE).fill().map(()=>Array(SIZE).fill(0));

  for(let y = 0; y < SIZE; y++) {
    for(let x = 0; x < SIZE; x++) {
      const c = document.createElement('div');
      c.className = 'cell';
      c.dataset.x = x;
      c.dataset.y = y;
      boardEl.appendChild(c);
    }
  }

  for(let i = 0; i < 10; i++) {
    let x, y;
    do {
      x = Math.floor(Math.random() * SIZE);
      y = Math.floor(Math.random() * SIZE);
    } while(board[y][x]);
    board[y][x] = Math.floor(Math.random() * 4) + 1;
  }

  renderBoard();
  hand = [];
  handEl.innerHTML = '';
  refillHand(); // 初期表示を確実に
  cleared.clear();
  counts = {2:0, 3:0, 4:0};
  moveCount = 0;
  updateMoveCount();
  updateNorma();
  gameOver = false;
  gameoverEl.classList.remove('show');
  clearScreen.classList.remove('show');
}

function updateMoveCount() {
  moveCountEl.textContent = moveCount;
}

function renderBoard() {
  document.querySelectorAll('#board .cell').forEach(el => {
    const x = +el.dataset.x, y = +el.dataset.y;
    const v = board[y][x];
    el.className = 'cell' + (v ? ` color-${v} filled` : '');
  });
}

function createPiece(origShape, cellColors) {
  const minY = Math.min(...origShape.map(p => p[0]));
  const minX = Math.min(...origShape.map(p => p[1]));

  const shape = origShape.map(([y,x]) => [y - minY, x - minX]);

  const h = 1 + Math.max(...shape.map(p => p[0]));
  const w = 1 + Math.max(...shape.map(p => p[1]));

  const grid = document.createElement('div');
  grid.className = 'piece-grid';
  grid.style.gridTemplateColumns = `repeat(${w}, 1fr)`;
  grid.style.gridTemplateRows = `repeat(${h}, 1fr)`;

  let cellIndex = 0;
  for(let gy = 0; gy < h; gy++) {
    for(let gx = 0; gx < w; gx++) {
      const cell = document.createElement('div');
      cell.className = 'piece-cell';
      if(shape.some(([sy,sx]) => sy === gy && sx === gx)) {
        const thisColor = cellColors[cellIndex % cellColors.length];
        cell.className += ` filled color-${thisColor}`;
        cellIndex++;
      }
      grid.appendChild(cell);
    }
  }

  const wrapper = document.createElement('div');
  wrapper.className = 'piece';
  wrapper.appendChild(grid);
  wrapper.draggable = !isTouchDevice;

  wrapper._shape = shape;
  wrapper._cellColors = cellColors;

  if (isTouchDevice) {
    let startX, startY, startTime;

    wrapper.addEventListener('touchstart', e => {
      if(gameOver) return;
      e.preventDefault();
      e.stopPropagation();
      const touch = e.touches[0];
      startX = touch.clientX;
      startY = touch.clientY;
      startTime = Date.now();

      const rect = wrapper.getBoundingClientRect();
      const relX = touch.clientX - rect.left;
      const relY = touch.clientY - rect.top;

      const cell = wrapper.querySelector('.piece-cell');
      const cellSize = cell ? cell.offsetWidth : 45;
      dragOffset.dx = Math.min(Math.max(0, Math.floor(relX / cellSize)), w - 1);
      dragOffset.dy = Math.min(Math.max(0, Math.floor(relY / cellSize)), h - 1);

      currentDragPiece = hand.find(p => p.el === wrapper);
      wrapper.classList.add('dragging');
    });

    wrapper.addEventListener('touchmove', e => {
      if(!currentDragPiece) return;
      e.preventDefault();
      e.stopPropagation();

      const touch = e.touches[0];
      const rect = boardEl.getBoundingClientRect();
      const relX = touch.clientX - rect.left;
      const relY = touch.clientY - rect.top;

      const cellWidth = boardEl.clientWidth / SIZE;
      const cellHeight = boardEl.clientHeight / SIZE;

      const dropX = Math.floor(relX / cellWidth);
      const dropY = Math.floor(relY / cellHeight);

      if(dropX >= 0 && dropX < SIZE && dropY >= 0 && dropY < SIZE) {
        const baseX = dropX - dragOffset.dx;
        const baseY = dropY - dragOffset.dy;
        showPreview(baseY, baseX, currentDragPiece);
      } else {
        clearPreview();
      }
    });

    wrapper.addEventListener('touchend', e => {
      if(!currentDragPiece) return;
      e.preventDefault();
      e.stopPropagation();

      const touch = e.changedTouches[0];
      const rect = boardEl.getBoundingClientRect();
      const relX = touch.clientX - rect.left;
      const relY = touch.clientY - rect.top;

      const cellWidth = boardEl.clientWidth / SIZE;
      const cellHeight = boardEl.clientHeight / SIZE;

      const dropX = Math.floor(relX / cellWidth);
      const dropY = Math.floor(relY / cellHeight);

      if(dropX >= 0 && dropX < SIZE && dropY >= 0 && dropY < SIZE) {
        const targetCell = boardEl.querySelector(`[data-x="${dropX}"][data-y="${dropY}"]`);
        if(targetCell) {
          const baseX = dropX - dragOffset.dx;
          const baseY = dropY - dragOffset.dy;

          let canPlace = true;
          for(const [dy, dx] of currentDragPiece.shape) {
            const nx = baseX + dx;
            const ny = baseY + dy;
            if(nx < 0 || nx >= SIZE || ny < 0 || ny >= SIZE || board[ny][nx] !== 0) {
              canPlace = false;
              break;
            }
          }

          if(canPlace) {
            for(let i = 0; i < currentDragPiece.shape.length; i++) {
              const [dy, dx] = currentDragPiece.shape[i];
              const nx = baseX + dx;
              const ny = baseY + dy;
              board[ny][nx] = currentDragPiece.cellColors[i % currentDragPiece.cellColors.length];
            }

            currentDragPiece.el.remove();
            hand.splice(hand.findIndex(p => p.el === currentDragPiece.el), 1);

            moveCount++;
            updateMoveCount();

            if (hand.length === 0) {
              refillHand();
            }

            renderBoard();
            checkClear();
          } else {
            targetCell.style.background = 'rgba(255,60,60,0.4)';
            setTimeout(() => targetCell.style.background = '', 300);
          }
        }
      }

      currentDragPiece = null;
      wrapper.classList.remove('dragging');
      clearPreview();
    });
  }

  return { el: wrapper, shape, cellColors };
}

function refillHand() {
  hand = [];
  handEl.innerHTML = '';
  for (let i = 0; i < 3; i++) {
    const shape = SHAPES[Math.floor(Math.random() * SHAPES.length)];

    let availColors = [1,2,3,4].filter(c => !cleared.has(c));
    if (availColors.length === 0) availColors = [1];

    const normaAvail = availColors.filter(c => NORMA_COLORS.includes(c));
    let selectedColors = [];

    while (selectedColors.length < shape.length) {
      if (selectedColors.length < 1 && normaAvail.length > 0) {
        selectedColors.push(normaAvail[Math.floor(Math.random() * normaAvail.length)]);
      } else {
        selectedColors.push(availColors[Math.floor(Math.random() * availColors.length)]);
      }
    }

    const p = createPiece(shape, selectedColors);
    hand.push(p);
    handEl.appendChild(p.el);
  }
}

function clearPreview() {
  currentPreviewCells.forEach(cell => cell.innerHTML = '');
  currentPreviewCells = [];
}

function showPreview(baseY, baseX, piece) {
  clearPreview();

  let canPreview = true;
  for(const [dy, dx] of piece.shape) {
    const ny = baseY + dy;
    const nx = baseX + dx;
    if(nx < 0 || nx >= SIZE || ny < 0 || ny >= SIZE || board[ny][nx] !== 0) {
      canPreview = false;
      break;
    }
  }

  if(!canPreview) return;

  for(let i = 0; i < piece.shape.length; i++) {
    const [dy, dx] = piece.shape[i];
    const ny = baseY + dy;
    const nx = baseX + dx;
    const targetCell = boardEl.querySelector(`[data-x="${nx}"][data-y="${ny}"]`);
    if(targetCell) {
      const preview = document.createElement('div');
      const thisColor = piece.cellColors[i % piece.cellColors.length];
      preview.className = `preview color-${thisColor}`;
      targetCell.appendChild(preview);
      currentPreviewCells.push(targetCell);
    }
  }
}

boardEl.addEventListener('dragover', e => {
  e.preventDefault();
  if(!currentDragPiece || isTouchDevice) return;

  const cell = e.target.closest('.cell');
  if(!cell) return;

  const x = +cell.dataset.x;
  const y = +cell.dataset.y;

  const baseX = x - dragOffset.dx;
  const baseY = y - dragOffset.dy;

  showPreview(baseY, baseX, currentDragPiece);
});

boardEl.addEventListener('drop', e => {
  if(gameOver || isTouchDevice) return;
  e.preventDefault();

  const idx = parseInt(e.dataTransfer.getData('text/plain'));
  if(isNaN(idx) || idx < 0 || idx >= hand.length) return;

  const piece = hand[idx];
  const cell = e.target.closest('.cell');
  if(!cell) return;

  const dropX = +cell.dataset.x;
  const dropY = +cell.dataset.y;

  const baseX = dropX - dragOffset.dx;
  const baseY = dropY - dragOffset.dy;

  let canPlace = true;
  for(const [dy, dx] of piece.shape) {
    const nx = baseX + dx;
    const ny = baseY + dy;
    if(nx < 0 || nx >= SIZE || ny < 0 || ny >= SIZE || board[ny][nx] !== 0) {
      canPlace = false;
      break;
    }
  }

  clearPreview();

  if(!canPlace) {
    cell.style.background = 'rgba(255,60,60,0.4)';
    setTimeout(() => cell.style.background = '', 300);
    return;
  }

  for(let i = 0; i < piece.shape.length; i++) {
    const [dy, dx] = piece.shape[i];
    const nx = baseX + dx;
    const ny = baseY + dy;
    board[ny][nx] = piece.cellColors[i % piece.cellColors.length];
  }

  piece.el.remove();
  hand.splice(idx, 1);

  moveCount++;
  updateMoveCount();

  if (hand.length === 0) {
    refillHand();
  }

  renderBoard();
  checkClear();
});

function checkClear() {
  let changed = false;
  const erased = {1:0,2:0,3:0,4:0};
  const toAnimate = [];

  for(let y = 0; y < SIZE; y++) {
    if(board[y].every(v => v > 0)) {
      for(let x = 0; x < SIZE; x++) {
        const cell = boardEl.querySelector(`[data-x="${x}"][data-y="${y}"]`);
        if(cell) toAnimate.push(cell);
        erased[board[y][x]]++;
        board[y][x] = 0;
      }
      changed = true;
    }
  }

  for(let x = 0; x < SIZE; x++) {
    if(board.every(row => row[x] > 0)) {
      for(let y = 0; y < SIZE; y++) {
        const cell = boardEl.querySelector(`[data-x="${x}"][data-y="${y}"]`);
        if(cell) toAnimate.push(cell);
        erased[board[y][x]]++;
        board[y][x] = 0;
      }
      changed = true;
    }
  }

  if(changed) {
    toAnimate.forEach(cell => cell.classList.add('clearing'));

    setTimeout(() => {
      renderBoard();

      NORMA_COLORS.forEach(c => {
        counts[c] += (erased[c] || 0);
        if(counts[c] >= TARGET && !cleared.has(c)) {
          cleared.add(c);
          for(let y = 0; y < SIZE; y++) for(let x = 0; x < SIZE; x++) {
            if(board[y][x] === c) board[y][x] = 1;
          }
          hand.forEach(p => {
            for(let i = 0; i < p.cellColors.length; i++) {
              if(p.cellColors[i] === c) p.cellColors[i] = 1;
            }
            p.el.querySelectorAll('.filled').forEach(el => {
              el.classList.remove(`color-${c}`);
              el.classList.add('color-1');
            });
          });
          renderBoard();
        }
      });

      updateNorma();

      if(NORMA_COLORS.every(c => counts[c] >= TARGET)) {
        gameOver = true;
        clearMoves.textContent = `クリア操作回数: ${moveCount}回`;
        clearScreen.classList.add('show');
      } else if(hand.length === 3 && !canPlaceAny()) {
        gameOver = true;
        gameoverEl.classList.add('show');
      }
    }, 600);
  }
}

function canPlaceAny() {
  for(const p of hand) {
    for(let y = 0; y < SIZE; y++) for(let x = 0; x < SIZE; x++) {
      let ok = true;
      for(const [dy, dx] of p.shape) {
        if(x + dx < 0 || x + dx >= SIZE || y + dy < 0 || y + dy >= SIZE || board[y + dy][x + dx] !== 0) {
          ok = false;
          break;
        }
      }
      if(ok) return true;
    }
  }
  return false;
}

function updateNorma() {
  document.getElementById('c2').textContent = `${counts[2]}/${TARGET}`;
  document.getElementById('c3').textContent = `${counts[3]}/${TARGET}`;
  document.getElementById('c4').textContent = `${counts[4]}/${TARGET}`;
}

init();
gameoverEl.addEventListener('click', init);
restartBtn.addEventListener('click', init);
resetBtn.addEventListener('click', init);
</script>
</body>
</html>
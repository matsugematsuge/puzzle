<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>å®çŸ³ãƒ‘ã‚ºãƒ«ã‚²ãƒ¼ãƒ </title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<style>
  /* å…¨ä½“è¨­å®š */
  * {
    touch-action: none !important;
    user-select: none;
    -webkit-user-select: none;
    box-sizing: border-box;
  }
  body {
    margin: 0; padding: 0; height: 100dvh;
    background: linear-gradient(135deg, #0f001a, #1a0033);
    color: #eee; font-family: system-ui, sans-serif;
    overflow: hidden; display: flex; flex-direction: column; align-items: center;
  }
  #container {
    width: 100%; max-width: 480px; padding: 10px;
    flex: 1; display: flex; flex-direction: column;
  }

  /* ä¸Šéƒ¨UI */
  #top-bar { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
  #norma { display: flex; gap: 8px; }
  .norma-item {
    background: rgba(40,20,80,0.7); border: 2px solid #6644aa; border-radius: 12px;
    padding: 4px 10px; text-align: center; min-width: 70px;
    font-size: 0.8rem; font-weight: bold; display: flex; align-items: center; gap: 4px;
  }
  .norma-green { color: #66ff99; }
  .norma-pink  { color: #ff99dd; }
  .norma-yellow{ color: #ffff88; }

  /* ç›¤é¢ */
  #board-container {
    background: #0a0a1a; border: 4px solid #443366; border-radius: 8px;
    width: 100%; aspect-ratio: 1 / 1; position: relative;
  }
  #board {
    display: grid; grid-template-columns: repeat(8, 1fr); grid-template-rows: repeat(8, 1fr);
    gap: 2px; padding: 2px; width: 100%; height: 100%;
  }
  .cell { background: rgba(255,255,255,0.05); border-radius: 4px; position: relative; }
  
  /* å®çŸ³ã®è‰² */
  .filled { box-shadow: inset 0 0 10px rgba(0,0,0,0.5); }
  .color-1 { background: #a0a0b0; } /* ç„¡è‰²ï¼ˆã‚°ãƒ¬ãƒ¼ï¼‰ */
  .color-2 { background: #66ff99; } /* ç·‘ */
  .color-3 { background: #ff99dd; } /* ãƒ”ãƒ³ã‚¯ */
  .color-4 { background: #ffff88; } /* é»„è‰² */

  /* æ‰‹æŒã¡ãƒ–ãƒ­ãƒƒã‚¯ */
  #hand {
    flex: 1; display: flex; justify-content: space-around; align-items: center; padding: 10px 0;
  }
  .piece { transition: transform 0.1s; cursor: grab; }
  .piece-grid { display: grid; gap: 2px; }
  .piece-cell { width: 30px; height: 30px; border-radius: 4px; }

  .preview { position: absolute; inset: 0; opacity: 0.4; border-radius: 4px; z-index: 5; }

  /* ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ */
  .overlay {
    position: absolute; inset: 0; background: rgba(0,0,0,0.9);
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    opacity: 0; pointer-events: none; transition: 0.5s; z-index: 100; text-align: center;
  }
  .overlay.show { opacity: 1; pointer-events: all; }
  .restart-btn {
    margin-top: 15px; padding: 12px 30px; background: #6644aa; color: white;
    border: none; border-radius: 25px; font-weight: bold; cursor: pointer;
  }
  #clear-stats { font-size: 1.2rem; margin-top: 10px; color: #ff99dd; }
</style>
</head>
<body>

<div id="container">
  <div id="top-bar">
    <div id="norma">
      <div class="norma-item norma-green">ğŸŸ© <span id="c2">0/5</span></div>
      <div class="norma-item norma-pink">ğŸŸ¥ <span id="c3">0/5</span></div>
      <div class="norma-item norma-yellow">ğŸŸ¨ <span id="c4">0/10</span></div>
    </div>
    <div style="font-size: 0.8rem; opacity: 0.7;">æ“ä½œ: <span id="moveCount">0</span></div>
    <button id="resetBtn" style="background:none; border:none; color:white; font-size:1.5rem;">â†»</button>
  </div>

  <div id="board-container">
    <div id="board"></div>
    <div class="overlay" id="gameover">GAME OVER</div>
    <div class="overlay" id="clearScreen">
      <h2 style="margin:0; color:#ffff88;">ğŸ‰ CLEAR! ğŸ‰</h2>
      <div id="clear-stats"></div>
      <button class="restart-btn" id="restartBtn">ã‚‚ã†ä¸€åº¦ã‚ãã¶</button>
    </div>
  </div>

  <div id="hand"></div>
</div>

<script>
// --- éŸ³å£°ç”Ÿæˆæ©Ÿèƒ½ ---
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
function playTone(freq, type, duration) {
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.type = type;
  osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
  gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
  osc.connect(gain);
  gain.connect(audioCtx.destination);
  osc.start();
  osc.stop(audioCtx.currentTime + duration);
}

const SIZE = 8;
let board = Array(SIZE).fill().map(()=>Array(SIZE).fill(0));
let counts = {2:0, 3:0, 4:0}, normaTargets = {2:5, 3:5, 4:10};
let clearedColors = new Set(), hand = [], moveCount = 0, gameOver = false;

const SHAPES = [
  [[0,0],[1,0],[2,0],[2,1]], [[0,0],[0,1],[0,2],[1,2]],
  [[0,0],[0,1]], [[0,0],[0,1],[0,2],[0,3]],
  [[0,0],[0,1],[1,0],[1,1]], [[0,0],[0,1],[0,2],[1,1]]
];

function init() {
  board = Array(SIZE).fill().map(()=>Array(SIZE).fill(0));
  counts = {2:0, 3:0, 4:0}; clearedColors.clear();
  moveCount = 0; gameOver = false;
  
  const boardEl = document.getElementById('board');
  boardEl.innerHTML = '';
  for(let y=0; y<SIZE; y++) {
    for(let x=0; x<SIZE; x++) {
      const cell = document.createElement('div');
      cell.className = 'cell';
      cell.dataset.x = x; cell.dataset.y = y;
      boardEl.appendChild(cell);
    }
  }

  for(let i=0; i<10; i++) {
    let x, y;
    do { x = Math.floor(Math.random()*SIZE); y = Math.floor(Math.random()*SIZE); } while(board[y][x]);
    board[y][x] = Math.floor(Math.random()*4) + 1;
  }

  refillHand(); render(); updateUI();
  document.querySelectorAll('.overlay').forEach(el => el.classList.remove('show'));
}

function refillHand() {
  const handEl = document.getElementById('hand');
  handEl.innerHTML = ''; hand = [];
  for(let i=0; i<3; i++) {
    const shape = SHAPES[Math.floor(Math.random()*SHAPES.length)];
    let availColors = [1,2,3,4].filter(c => !clearedColors.has(c));
    if (availColors.length === 0) availColors = [1];
    
    const normaAvail = availColors.filter(c => [2,3,4].includes(c));
    const pieceColors = shape.map((_, idx) => {
      if (idx === 0 && normaAvail.length > 0) return normaAvail[Math.floor(Math.random()*normaAvail.length)];
      return availColors[Math.floor(Math.random()*availColors.length)];
    });
    
    const pieceObj = { shape, colors: pieceColors };
    hand.push(pieceObj);
    handEl.appendChild(createPieceEl(pieceObj, i));
  }
}

function createPieceEl(piece, index) {
  const grid = document.createElement('div');
  grid.className = 'piece';
  const w = Math.max(...piece.shape.map(s => s[1])) + 1;
  const h = Math.max(...piece.shape.map(s => s[0])) + 1;
  const inner = document.createElement('div');
  inner.className = 'piece-grid';
  inner.style.gridTemplateColumns = `repeat(${w}, 1fr)`;
  
  for(let y=0; y<h; y++) {
    for(let x=0; x<w; x++) {
      const cell = document.createElement('div');
      cell.className = 'piece-cell';
      const colorIdx = piece.shape.findIndex(s => s[0] === y && s[1] === x);
      if(colorIdx !== -1) cell.classList.add(`color-${piece.colors[colorIdx]}`, 'filled');
      inner.appendChild(cell);
    }
  }
  grid.appendChild(inner);

  grid.addEventListener('touchstart', (e) => {
    if(gameOver) return;
    if(audioCtx.state === 'suspended') audioCtx.resume();
    activeIdx = index; dragEl = grid;
    grid.style.transform = 'scale(1.1)';
  });
  grid.addEventListener('touchmove', handleMove);
  grid.addEventListener('touchend', handleEnd);
  return grid;
}

let activeIdx = -1, dragEl = null, lastTarget = null;

function handleMove(e) {
  if(activeIdx === -1) return;
  const touch = e.touches[0];
  const boardRect = document.getElementById('board').getBoundingClientRect();
  const x = Math.floor((touch.clientX - boardRect.left) / (boardRect.width / SIZE));
  const y = Math.floor((touch.clientY - boardRect.top) / (boardRect.height / SIZE));

  document.querySelectorAll('.preview').forEach(p => p.remove());
  if(x >= 0 && x < SIZE && y >= 0 && y < SIZE) {
    showPreview(y, x, hand[activeIdx]);
    lastTarget = {x, y};
  } else { lastTarget = null; }
}

function handleEnd() {
  if(activeIdx === -1) return;
  if(lastTarget && placePiece(lastTarget.y, lastTarget.x, hand[activeIdx])) {
    playTone(660, 'sine', 0.1); // ç½®ã„ãŸæ™‚ã®éŸ³
    hand[activeIdx] = null;
    dragEl.style.visibility = 'hidden';
    moveCount++;
    if(hand.every(h => h === null)) refillHand();
    checkBoard();
  }
  if(dragEl) dragEl.style.transform = '';
  document.querySelectorAll('.preview').forEach(p => p.remove());
  activeIdx = -1; render(); updateUI();
}

function showPreview(by, bx, piece) {
  if(!canPlace(by, bx, piece)) return;
  piece.shape.forEach((s, i) => {
    const cell = document.querySelector(`.cell[data-x="${bx+s[1]}"][data-y="${by+s[0]}"]`);
    if(cell) {
      const p = document.createElement('div');
      p.className = `preview color-${piece.colors[i]}`;
      cell.appendChild(p);
    }
  });
}

function canPlace(by, bx, piece) {
  return piece.shape.every(s => {
    const ny = by + s[0], nx = bx + s[1];
    return ny < SIZE && nx < SIZE && board[ny][nx] === 0;
  });
}

function placePiece(by, bx, piece) {
  if(!canPlace(by, bx, piece)) return false;
  piece.shape.forEach((s, i) => {
    const color = piece.colors[i];
    board[by+s[0]][bx+s[1]] = color;
    if(counts[color] !== undefined) counts[color]++;
  });
  return true;
}

function checkBoard() {
  let linesY = [], linesX = [];
  for(let i=0; i<SIZE; i++) {
    if(board[i].every(v => v > 0)) linesY.push(i);
    if(board.every(row => row[i] > 0)) linesX.push(i);
  }
  
  if(linesY.length > 0 || linesX.length > 0) {
    playTone(880, 'sine', 0.2); // åˆ—ãŒæ¶ˆãˆãŸæ™‚ã®éŸ³
    linesY.forEach(y => board[y].fill(0));
    linesX.forEach(x => board.forEach(row => row[x] = 0));
  }

  [2,3,4].forEach(c => {
    if(counts[c] >= normaTargets[c] && !clearedColors.has(c)) {
      clearedColors.add(c);
      playTone(1320, 'square', 0.3); // ãƒãƒ«ãƒã‚¯ãƒªã‚¢ã®éŸ³
      for(let y=0; y<SIZE; y++) for(let x=0; x<SIZE; x++) if(board[y][x] === c) board[y][x] = 1;
      hand.forEach(p => { if(p) p.colors = p.colors.map(col => col === c ? 1 : col); });
    }
  });

  if(clearedColors.size === 3) {
    gameOver = true;
    document.getElementById('clear-stats').innerText = `åˆè¨ˆæ“ä½œå›æ•°: ${moveCount}å›`;
    document.getElementById('clearScreen').classList.add('show');
  }
}

function render() {
  document.querySelectorAll('.cell').forEach(el => {
    const v = board[el.dataset.y][el.dataset.x];
    el.className = 'cell' + (v ? ` color-${v} filled` : '');
  });
}

function updateUI() {
  [2,3,4].forEach(c => { document.getElementById(`c${c}`).innerText = `${counts[c]}/${normaTargets[c]}`; });
  document.getElementById('moveCount').innerText = moveCount;
}

init();
document.getElementById('resetBtn').onclick = init;
document.getElementById('restartBtn').onclick = init;
</script>
</body>
</html>
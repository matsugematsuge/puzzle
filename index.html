<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>å®çŸ³ãƒ‘ã‚ºãƒ«ã‚²ãƒ¼ãƒ  - ä¿®æ­£ç‰ˆ</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<style>
  /* åŸºæœ¬ã‚¹ã‚¿ã‚¤ãƒ« */
  * {
    touch-action: none !important;
    user-select: none;
    -webkit-user-select: none;
    box-sizing: border-box;
  }
  body {
    margin: 0; padding: 0; height: 100dvh;
    background: linear-gradient(135deg, #0f001a, #1a0033);
    color: #eee; font-family: system-ui, sans-serif;
    overflow: hidden; display: flex; flex-direction: column; align-items: center;
  }
  #container {
    width: 100%; max-width: 480px; padding: 10px;
    flex: 1; display: flex; flex-direction: column;
  }

  /* ä¸Šéƒ¨UI */
  #top-bar { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
  #norma { display: flex; gap: 8px; }
  .norma-item {
    background: rgba(40,20,80,0.7); border: 2px solid #6644aa; border-radius: 12px;
    padding: 4px 10px; text-align: center; min-width: 70px;
    font-size: 0.8rem; font-weight: bold; display: flex; align-items: center; gap: 4px;
  }
  .norma-green { color: #66ff99; }
  .norma-pink  { color: #ff99dd; }
  .norma-yellow{ color: #ffff88; }

  /* ç›¤é¢ */
  #board-container {
    background: #0a0a1a; border: 4px solid #443366; border-radius: 8px;
    width: 100%; aspect-ratio: 1 / 1; position: relative;
  }
  #board {
    display: grid; grid-template-columns: repeat(8, 1fr); grid-template-rows: repeat(8, 1fr);
    gap: 2px; padding: 2px; width: 100%; height: 100%;
  }
  .cell { background: rgba(255,255,255,0.05); border-radius: 4px; position: relative; }
  
  /* å®çŸ³ã®è‰² */
  .filled { box-shadow: inset 0 0 10px rgba(0,0,0,0.5); }
  .color-1 { background: #a0a0b0; } /* ç„¡è‰²ã‚°ãƒ¬ãƒ¼ */
  .color-2 { background: #66ff99; }
  .color-3 { background: #ff99dd; }
  .color-4 { background: #ffff88; }

  /* æ‰‹æŒã¡ãƒ–ãƒ­ãƒƒã‚¯ */
  #hand {
    flex: 1; display: flex; justify-content: space-around; align-items: center; padding: 10px 0;
  }
  .piece { transition: transform 0.1s; cursor: grab; }
  .piece-grid { display: grid; gap: 2px; }
  .piece-cell { width: 28px; height: 28px; border-radius: 4px; }

  .preview { position: absolute; inset: 0; opacity: 0.4; border-radius: 4px; z-index: 5; pointer-events: none; }

  .overlay {
    position: absolute; inset: 0; background: rgba(0,0,0,0.9);
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    opacity: 0; pointer-events: none; transition: 0.5s; z-index: 100; text-align: center;
  }
  .overlay.show { opacity: 1; pointer-events: all; }
  .restart-btn {
    margin-top: 15px; padding: 12px 30px; background: #6644aa; color: white;
    border: none; border-radius: 25px; font-weight: bold; cursor: pointer;
  }
</style>
</head>
<body>

<div id="container">
  <div id="top-bar">
    <div id="norma">
      <div class="norma-item norma-green">ğŸŸ© <span id="c2">0/5</span></div>
      <div class="norma-item norma-pink">ğŸŸ¥ <span id="c3">0/5</span></div>
      <div class="norma-item norma-yellow">ğŸŸ¨ <span id="c4">0/10</span></div>
    </div>
    <div style="font-size: 0.8rem; opacity: 0.7;">æ“ä½œ: <span id="moveCount">0</span></div>
    <button id="resetBtn" style="background:none; border:none; color:white; font-size:1.5rem;">â†»</button>
  </div>

  <div id="board-container">
    <div id="board"></div>
    <div class="overlay" id="gameover">GAME OVER</div>
    <div class="overlay" id="clearScreen">
      <h2 style="margin:0; color:#ffff88;">ğŸ‰ CLEAR! ğŸ‰</h2>
      <div id="clear-stats" style="margin-top:10px; font-size:1.2rem; color:#ff99dd;"></div>
      <button class="restart-btn" id="restartBtn">ã‚‚ã†ä¸€åº¦ã‚ãã¶</button>
    </div>
  </div>

  <div id="hand"></div>
</div>

<script>
/** * éŸ³å£°ç”Ÿæˆ */
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
function playTone(freq, type, duration) {
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.type = type;
  osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
  gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
  osc.connect(gain); gain.connect(audioCtx.destination);
  osc.start(); osc.stop(audioCtx.currentTime + duration);
}

/** * ãƒ–ãƒ­ãƒƒã‚¯å®šç¾©ã¨è¨­å®š */
const SIZE = 8;
const BLOCK_DEFINITIONS = [
  { name: "ãƒŠãƒãƒ¥ãƒ©ãƒ«", freq: 8, shape: [[0,0], [1,0], [1,1], [2,1]], minN: 1, maxN: 2 },
  { name: "Tå­—", freq: 8, shape: [[0,1], [1,0], [1,1], [1,2]], minN: 1, maxN: 2 },
  { name: "1ãƒã‚¹", freq: 6, shape: [[0,0]], minN: 0, maxN: 1 },
  { name: "ç›´ç·š2ãƒã‚¹", freq: 5, shape: [[0,0], [0,1]], minN: 1, maxN: 2 },
  { name: "ç›´ç·š3ãƒã‚¹", freq: 7, shape: [[0,0], [0,1], [0,2]], minN: 1, maxN: 2 },
  { name: "ç›´ç·š4ãƒã‚¹", freq: 5, shape: [[0,0], [0,1], [0,2], [0,3]], minN: 1, maxN: 3 },
  { name: "ç›´ç·š5ãƒã‚¹", freq: 4, shape: [[0,0], [0,1], [0,2], [0,3], [0,4]], minN: 1, maxN: 3 },
  { name: "Lå­—_å°", freq: 5, shape: [[0,0], [1,0], [1,1]], minN: 1, maxN: 2 },
  { name: "Lå­—_ä¸­", freq: 8, shape: [[0,0], [1,0], [2,0], [2,1]], minN: 1, maxN: 2 },
  { name: "Lå­—_å¤§", freq: 5, shape: [[0,0], [1,0], [2,0], [3,0], [3,1], [3,2], [3,3]], minN: 1, maxN: 4 },
  { name: "éšæ®µ_å°", freq: 7, shape: [[0,0], [1,1]], minN: 1, maxN: 2 },
  { name: "éšæ®µ_å¤§", freq: 6, shape: [[0,0], [1,1], [2,2]], minN: 1, maxN: 2 },
  { name: "å››è§’_å°", freq: 6, shape: [[0,0], [0,1], [1,0], [1,1]], minN: 1, maxN: 2 },
  { name: "å››è§’_å¤§", freq: 5, shape: [[0,0], [0,1], [0,2], [1,0], [1,1], [1,2]], minN: 1, maxN: 4 }
];

let board = Array(SIZE).fill().map(()=>Array(SIZE).fill(0));
let counts = {2:0, 3:0, 4:0};
let normaTargets = {2:5, 3:5, 4:10};
let clearedColors = new Set();
let hand = [];
let moveCount = 0;
let gameOver = false;
let dragOffset = { dx: 0, dy: 0 };
let activeIdx = -1;
let dragEl = null;

function getAllVariants(shape) {
  const variants = [];
  const normalize = (s) => {
    const minY = Math.min(...s.map(p => p[0]));
    const minX = Math.min(...s.map(p => p[1]));
    return s.map(p => [p[0] - minY, p[1] - minX]).sort((a,b) => a[0]-b[0] || a[1]-b[1]);
  };
  const isSame = (s1, s2) => JSON.stringify(s1) === JSON.stringify(s2);
  let current = shape;
  for (let r = 0; r < 4; r++) {
    [current, current.map(p => [p[0], -p[1]]), current.map(p => [-p[0], p[1]])].forEach(variant => {
      const norm = normalize(variant);
      if (!variants.some(v => isSame(v, norm))) variants.push(norm);
    });
    current = current.map(p => [p[1], -p[0]]);
  }
  return variants;
}

function init() {
  board = Array(SIZE).fill().map(()=>Array(SIZE).fill(0));
  counts = {2:0, 3:0, 4:0}; 
  clearedColors.clear();
  moveCount = 0; 
  gameOver = false;

  const boardEl = document.getElementById('board');
  boardEl.innerHTML = '';
  for(let y=0; y<SIZE; y++) {
    for(let x=0; x<SIZE; x++) {
      const cell = document.createElement('div');
      cell.className = 'cell'; cell.dataset.x = x; cell.dataset.y = y;
      boardEl.appendChild(cell);
    }
  }

  // åˆæœŸç›¤é¢ã®å®çŸ³é…ç½® (ä¿®æ­£ç®‡æ‰€)
  for(let i=0; i<10; i++) {
    let x, y;
    do { x = Math.floor(Math.random()*SIZE); y = Math.floor(Math.random()*SIZE); } while(board[y][x] !== 0);
    board[y][x] = Math.floor(Math.random()*4) + 1;
  }

  refillHand(); render(); updateUI();
  document.querySelectorAll('.overlay').forEach(el => el.classList.remove('show'));
}

function refillHand() {
  const handEl = document.getElementById('hand');
  handEl.innerHTML = ''; hand = [];
  const totalFreq = BLOCK_DEFINITIONS.reduce((sum, b) => sum + b.freq, 0);

  for(let i=0; i<3; i++) {
    let rand = Math.random() * totalFreq;
    let base;
    for (const b of BLOCK_DEFINITIONS) { if (rand < b.freq) { base = b; break; } rand -= b.freq; }

    const variants = getAllVariants(base.shape);
    const selectedShape = variants[Math.floor(Math.random() * variants.length)];
    let availNorma = [2, 3, 4].filter(c => !clearedColors.has(c));
    const targetNormaCount = Math.floor(Math.random() * (base.maxN - base.minN + 1)) + base.minN;
    const colorIndices = Array.from({length: selectedShape.length}, (_, i) => i).sort(() => Math.random() - 0.5);
    const pieceColors = Array(selectedShape.length).fill(1);
    
    for (let n = 0; n < targetNormaCount && n < selectedShape.length; n++) {
      pieceColors[colorIndices[n]] = availNorma.length > 0 ? availNorma[Math.floor(Math.random() * availNorma.length)] : 1;
    }

    const pieceObj = { shape: selectedShape, colors: pieceColors };
    hand.push(pieceObj);
    handEl.appendChild(createPieceEl(pieceObj, i));
  }
}

function createPieceEl(piece, index) {
  const grid = document.createElement('div');
  grid.className = 'piece';
  const w = Math.max(...piece.shape.map(s => s[1])) + 1;
  const h = Math.max(...piece.shape.map(s => s[0])) + 1;
  const inner = document.createElement('div');
  inner.className = 'piece-grid';
  inner.style.gridTemplateColumns = `repeat(${w}, 1fr)`;
  for(let y=0; y<h; y++) {
    for(let x=0; x<w; x++) {
      const cell = document.createElement('div');
      cell.className = 'piece-cell';
      const colorIdx = piece.shape.findIndex(s => s[0] === y && s[1] === x);
      if(colorIdx !== -1) cell.classList.add(`color-${piece.colors[colorIdx]}`, 'filled');
      inner.appendChild(cell);
    }
  }
  grid.appendChild(inner);
  grid.addEventListener('touchstart', (e) => {
    if(gameOver) return;
    if(audioCtx.state === 'suspended') audioCtx.resume();
    const touch = e.touches[0];
    const rect = grid.getBoundingClientRect();
    const cellSize = rect.width / w;
    dragOffset.dx = Math.floor((touch.clientX - rect.left) / cellSize);
    dragOffset.dy = Math.floor((touch.clientY - rect.top) / cellSize);
    activeIdx = index; dragEl = grid;
    grid.style.transform = 'scale(1.1)';
  });
  grid.addEventListener('touchmove', handleMove);
  grid.addEventListener('touchend', handleEnd);
  return grid;
}

function handleMove(e) {
  if(activeIdx === -1) return;
  const touch = e.touches[0];
  const boardEl = document.getElementById('board');
  const rect = boardEl.getBoundingClientRect();
  const dropX = Math.floor((touch.clientX - rect.left) / (rect.width / SIZE));
  const dropY = Math.floor((touch.clientY - rect.top) / (rect.height / SIZE));
  clearPreview();
  if(dropX >= 0 && dropX < SIZE && dropY >= 0 && dropY < SIZE) {
    showPreview(dropY - dragOffset.dy, dropX - dragOffset.dx, hand[activeIdx]);
  }
}

function handleEnd(e) {
  if(activeIdx === -1) return;
  const touch = e.changedTouches[0];
  const boardEl = document.getElementById('board');
  const rect = boardEl.getBoundingClientRect();
  const dropX = Math.floor((touch.clientX - rect.left) / (rect.width / SIZE));
  const dropY = Math.floor((touch.clientY - rect.top) / (rect.height / SIZE));
  if(placePiece(dropY - dragOffset.dy, dropX - dragOffset.dx, hand[activeIdx])) {
    playTone(660, 'sine', 0.1);
    hand[activeIdx] = null;
    dragEl.style.visibility = 'hidden';
    moveCount++;
    if(hand.every(h => h === null)) refillHand();
    checkBoard();
  }
  if(dragEl) dragEl.style.transform = '';
  clearPreview(); activeIdx = -1; render(); updateUI();
}

function clearPreview() { document.querySelectorAll('.preview').forEach(p => p.remove()); }

function showPreview(by, bx, piece) {
  if(!canPlace(by, bx, piece)) return;
  piece.shape.forEach((s, i) => {
    const cell = document.querySelector(`.cell[data-x="${bx+s[1]}"][data-y="${by+s[0]}"]`);
    if(cell) {
      const p = document.createElement('div');
      p.className = `preview color-${piece.colors[i]}`;
      cell.appendChild(p);
    }
  });
}

function canPlace(by, bx, piece) {
  return piece.shape.every(s => {
    const ny = by + s[0], nx = bx + s[1];
    return ny >= 0 && ny < SIZE && nx >= 0 && nx < SIZE && board[ny][nx] === 0;
  });
}

function placePiece(by, bx, piece) {
  if(!canPlace(by, bx, piece)) return false;
  piece.shape.forEach((s, i) => { board[by+s[0]][bx+s[1]] = piece.colors[i]; });
  return true;
}

function checkBoard() {
  let linesY = [], linesX = [];
  for(let i=0; i<SIZE; i++) {
    if(board[i].every(v => v > 0)) linesY.push(i);
    if(board.every(row => row[i] > 0)) linesX.push(i);
  }
  if(linesY.length > 0 || linesX.length > 0) {
    playTone(880, 'sine', 0.2);
    let cellsToClear = new Set();
    linesY.forEach(y => { for(let x=0; x<SIZE; x++) cellsToClear.add(`${y},${x}`); });
    linesX.forEach(x => { for(let y=0; y<SIZE; y++) cellsToClear.add(`${y},${x}`); });
    cellsToClear.forEach(coord => {
      const [y, x] = coord.split(',').map(Number);
      const color = board[y][x];
      if (counts[color] !== undefined && !clearedColors.has(color)) counts[color]++;
      board[y][x] = 0;
    });
    [2,3,4].forEach(c => {
      if(counts[c] >= normaTargets[c] && !clearedColors.has(c)) {
        clearedColors.add(c);
        playTone(1320, 'square', 0.3);
        for(let y=0; y<SIZE; y++) for(let x=0; x<SIZE; x++) if(board[y][x] === c) board[y][x] = 1;
        hand.forEach(p => { if(p) p.colors = p.colors.map(col => col === c ? 1 : col); });
      }
    });
  }
  if(clearedColors.size === 3) {
    gameOver = true;
    document.getElementById('clear-stats').innerText = `ã‚¯ãƒªã‚¢æ“ä½œå›æ•°: ${moveCount}å›`;
    document.getElementById('clearScreen').classList.add('show');
  } else if(hand.length === 3 && !canPlaceAny()) {
    gameOver = true;
    document.getElementById('gameover').classList.add('show');
  }
}

function canPlaceAny() {
  return hand.some(p => {
    if(!p) return false;
    for(let y=0; y<SIZE; y++) for(let x=0; x<SIZE; x++) if(canPlace(y, x, p)) return true;
    return false;
  });
}

function render() {
  document.querySelectorAll('.cell').forEach(el => {
    const v = board[el.dataset.y][el.dataset.x];
    el.className = 'cell' + (v ? ` color-${v} filled` : '');
  });
}

function updateUI() {
  [2,3,4].forEach(c => { document.getElementById(`c${c}`).innerText = `${counts[c]}/${normaTargets[c]}`; });
  document.getElementById('moveCount').innerText = moveCount;
}

init();
document.getElementById('resetBtn').onclick = init;
document.getElementById('restartBtn').onclick = init;
</script>
</body>
</html>
<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>å®çŸ³ãƒ‘ã‚ºãƒ«ã‚²ãƒ¼ãƒ  - å®‰å®šä¿®æ­£ç‰ˆ</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<style>
  * { touch-action: none !important; user-select: none; -webkit-user-select: none; box-sizing: border-box; }
  body {
    margin: 0; padding: 0; height: 100dvh; background: linear-gradient(135deg, #0f001a, #1a0033);
    color: #eee; font-family: system-ui, sans-serif; overflow: hidden; display: flex; flex-direction: column; align-items: center;
  }
  #container { width: 100%; max-width: 480px; padding: 10px; flex: 1; display: flex; flex-direction: column; }
  #top-bar { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
  #norma { display: flex; gap: 6px; }
  .norma-item {
    background: rgba(40,20,80,0.7); border: 2px solid #6644aa; border-radius: 12px;
    padding: 4px 8px; text-align: center; min-width: 65px; font-size: 0.75rem; font-weight: bold; display: flex; align-items: center; gap: 4px;
  }
  .norma-green { color: #66ff99; } .norma-pink { color: #ff99dd; } .norma-yellow { color: #ffff88; }
  #board-container {
    background: #0a0a1a; border: 4px solid #443366; border-radius: 8px; width: 100%; aspect-ratio: 1 / 1; position: relative; box-shadow: 0 0 20px rgba(0,0,0,0.5);
  }
  #board { display: grid; grid-template-columns: repeat(8, 1fr); grid-template-rows: repeat(8, 1fr); gap: 2px; padding: 2px; width: 100%; height: 100%; }
  .cell { background: rgba(255,255,255,0.05); border-radius: 4px; position: relative; }
  .filled { box-shadow: inset 0 0 8px rgba(0,0,0,0.6); }
  .color-1 { background: #a0a0b0; border: 1px solid rgba(255,255,255,0.2); }
  .color-2 { background: #66ff99; border: 1px solid rgba(255,255,255,0.3); }
  .color-3 { background: #ff99dd; border: 1px solid rgba(255,255,255,0.3); }
  .color-4 { background: #ffff88; border: 1px solid rgba(255,255,255,0.3); }
  #hand { flex: 1; display: flex; justify-content: space-around; align-items: center; padding: 5px 0; }
  .piece { transition: transform 0.1s; cursor: grab; }
  .piece-grid { display: grid; gap: 1px; }
  .piece-cell { width: 22px; height: 22px; border-radius: 3px; }
  .preview { position: absolute; inset: 0; opacity: 0.5; border-radius: 4px; z-index: 5; pointer-events: none; }
  .overlay { position: absolute; inset: 0; background: rgba(0,0,0,0.9); display: flex; flex-direction: column; align-items: center; justify-content: center; opacity: 0; pointer-events: none; transition: 0.5s; z-index: 100; text-align: center; }
  .overlay.show { opacity: 1; pointer-events: all; }
  .restart-btn { margin-top: 15px; padding: 12px 30px; background: #6644aa; color: white; border: none; border-radius: 25px; font-weight: bold; cursor: pointer; }
</style>
</head>
<body>

<div id="container">
  <div id="top-bar">
    <div id="norma">
      <div class="norma-item norma-green">ğŸŸ© <span id="c2">0/5</span></div>
      <div class="norma-item norma-pink">ğŸŸ¥ <span id="c3">0/5</span></div>
      <div class="norma-item norma-yellow">ğŸŸ¨ <span id="c4">0/10</span></div>
    </div>
    <div style="font-size: 0.8rem; opacity: 0.7;">æ“ä½œ: <span id="moveCount">0</span></div>
    <button id="resetBtn" style="background:none; border:none; color:white; font-size:1.5rem;">â†»</button>
  </div>
  <div id="board-container"><div id="board"></div><div class="overlay" id="gameover">GAME OVER</div><div class="overlay" id="clearScreen"><h2 style="margin:0; color:#ffff88;">ğŸ‰ CLEAR! ğŸ‰</h2><div id="clear-stats" style="margin-top:10px; font-size:1.2rem; color:#ff99dd;"></div><button class="restart-btn" id="restartBtn">ã‚‚ã†ä¸€åº¦ã‚ãã¶</button></div></div>
  <div id="hand"></div>
</div>

<script>
// --- éŸ³å£°ç”Ÿæˆ ---
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
function playTone(freq, type, duration) {
  if (audioCtx.state === 'suspended') audioCtx.resume();
  try {
    const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
    osc.type = type; osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
    gain.gain.setValueAtTime(0.1, audioCtx.currentTime); gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
    osc.connect(gain); gain.connect(audioCtx.destination);
    osc.start(); osc.stop(audioCtx.currentTime + duration);
  } catch(e) {}
}

const SIZE = 8;
const BLOCK_DEFINITIONS = [
  { freq: 8, shape: [[0,0], [1,0], [1,1], [2,1]], minN: 1, maxN: 2 },
  { freq: 8, shape: [[0,1], [1,0], [1,1], [1,2]], minN: 1, maxN: 2 },
  { freq: 6, shape: [[0,0]], minN: 0, maxN: 1 },
  { freq: 5, shape: [[0,0], [0,1]], minN: 1, maxN: 2 },
  { freq: 7, shape: [[0,0], [0,1], [0,2]], minN: 1, maxN: 2 },
  { freq: 5, shape: [[0,0], [0,1], [0,2], [0,3]], minN: 1, maxN: 3 },
  { freq: 4, shape: [[0,0], [0,1], [0,2], [0,3], [0,4]], minN: 1, maxN: 3 },
  { freq: 5, shape: [[0,0], [1,0], [1,1]], minN: 1, maxN: 2 },
  { freq: 8, shape: [[0,0], [1,0], [2,0], [2,1]], minN: 1, maxN: 2 },
  { freq: 5, shape: [[0,0], [1,0], [2,0], [3,0], [3,1], [3,2], [3,3]], minN: 1, maxN: 4 },
  { freq: 7, shape: [[0,0], [1,1]], minN: 1, maxN: 2 },
  { freq: 6, shape: [[0,0], [1,1], [2,2]], minN: 1, maxN: 2 },
  { freq: 6, shape: [[0,0], [0,1], [1,0], [1,1]], minN: 1, maxN: 2 },
  { freq: 5, shape: [[0,0], [0,1], [0,2], [1,0], [1,1], [1,2]], minN: 1, maxN: 4 }
];

let board = [];
let counts = {2:0, 3:0, 4:0};
let normaTargets = {2:5, 3:5, 4:10};
let clearedColors = new Set();
let hand = [];
let moveCount = 0;
let gameOver = false;
let dragOffset = { dx: 0, dy: 0 };
let activeIdx = -1;
let dragEl = null;

function getAllVariants(shape) {
  const variants = [];
  const normalize = (s) => {
    const minY = Math.min(...s.map(p => p[0])); const minX = Math.min(...s.map(p => p[1]));
    return s.map(p => [p[0] - minY, p[1] - minX]).sort((a,b) => a[0]-b[0] || a[1]-b[1]);
  };
  let cur = shape;
  for (let r = 0; r < 4; r++) {
    [cur, cur.map(p => [p[0], -p[1]]), cur.map(p => [-p[0], p[1]])].forEach(v => {
      const n = normalize(v); if (!variants.some(x => JSON.stringify(x) === JSON.stringify(n))) variants.push(n);
    });
    cur = cur.map(p => [p[1], -p[0]]);
  }
  return variants;
}

function init() {
  // é…åˆ—ã‚’æ˜ç¤ºçš„ã«ä½œæˆï¼ˆã‚¹ãƒãƒ›ã®ãƒ¡ãƒ¢ãƒªç¢ºä¿ãƒŸã‚¹å¯¾ç­–ï¼‰
  board = [];
  for(let y=0; y<SIZE; y++) {
    let row = [];
    for(let x=0; x<SIZE; x++) row.push(0);
    board.push(row);
  }
  
  counts = {2:0, 3:0, 4:0}; clearedColors.clear();
  moveCount = 0; gameOver = false;

  const boardEl = document.getElementById('board');
  boardEl.innerHTML = '';
  for(let y=0; y<SIZE; y++) {
    for(let x=0; x<SIZE; x++) {
      const cell = document.createElement('div');
      cell.className = 'cell'; cell.id = `cell-${y}-${x}`;
      cell.dataset.x = x; cell.dataset.y = y;
      boardEl.appendChild(cell);
    }
  }

  // åˆæœŸå®çŸ³é…ç½® (ç¢ºå®Ÿã«ä»£å…¥)
  let placed = 0;
  while(placed < 10) {
    let x = Math.floor(Math.random()*SIZE), y = Math.floor(Math.random()*SIZE);
    if(board[y][x] === 0) {
      board[y][x] = Math.floor(Math.random()*4) + 1;
      placed++;
    }
  }

  refillHand(); render(); updateUI();
  document.querySelectorAll('.overlay').forEach(el => el.classList.remove('show'));
}

function refillHand() {
  const handEl = document.getElementById('hand');
  handEl.innerHTML = ''; hand = [];
  const totalFreq = BLOCK_DEFINITIONS.reduce((sum, b) => sum + b.freq, 0);
  for(let i=0; i<3; i++) {
    let rand = Math.random() * totalFreq, base;
    for (const b of BLOCK_DEFINITIONS) { if (rand < b.freq) { base = b; break; } rand -= b.freq; }
    const variants = getAllVariants(base.shape);
    const selectedShape = variants[Math.floor(Math.random() * variants.length)];
    let availNorma = [2, 3, 4].filter(c => !clearedColors.has(c));
    const targetN = Math.floor(Math.random() * (base.maxN - base.minN + 1)) + base.minN;
    const colorIdxs = Array.from({length: selectedShape.length}, (_, k) => k).sort(() => Math.random() - 0.5);
    const pieceColors = Array(selectedShape.length).fill(1);
    for (let n = 0; n < targetN && n < selectedShape.length; n++) {
      pieceColors[colorIdxs[n]] = availNorma.length > 0 ? availNorma[Math.floor(Math.random() * availNorma.length)] : 1;
    }
    const pieceObj = { shape: selectedShape, colors: pieceColors };
    hand.push(pieceObj); handEl.appendChild(createPieceEl(pieceObj, i));
  }
}

function createPieceEl(piece, index) {
  const grid = document.createElement('div'); grid.className = 'piece';
  const w = Math.max(...piece.shape.map(s => s[1])) + 1;
  const h = Math.max(...piece.shape.map(s => s[0])) + 1;
  const inner = document.createElement('div'); inner.className = 'piece-grid';
  inner.style.gridTemplateColumns = `repeat(${w}, 1fr)`;
  for(let y=0; y<h; y++) {
    for(let x=0; x<w; x++) {
      const cell = document.createElement('div'); cell.className = 'piece-cell';
      const cIdx = piece.shape.findIndex(s => s[0] === y && s[1] === x);
      if(cIdx !== -1) cell.classList.add(`color-${piece.colors[cIdx]}`, 'filled');
      inner.appendChild(cell);
    }
  }
  grid.appendChild(inner);
  grid.addEventListener('touchstart', (e) => {
    if(gameOver) return; if (audioCtx.state === 'suspended') audioCtx.resume();
    const touch = e.touches[0]; const rect = grid.getBoundingClientRect();
    dragOffset.dx = Math.floor((touch.clientX - rect.left) / (rect.width / w));
    dragOffset.dy = Math.floor((touch.clientY - rect.top) / (rect.height / h));
    activeIdx = index; dragEl = grid; grid.style.transform = 'scale(1.15)'; grid.style.opacity = '0.8';
  }, {passive: false});
  grid.addEventListener('touchmove', handleMove, {passive: false});
  grid.addEventListener('touchend', handleEnd, {passive: false});
  return grid;
}

function handleMove(e) {
  if(activeIdx === -1) return; e.preventDefault();
  const touch = e.touches[0]; const rect = document.getElementById('board').getBoundingClientRect();
  const dx = Math.floor((touch.clientX - rect.left) / (rect.width / SIZE));
  const dy = Math.floor((touch.clientY - rect.top) / (rect.height / SIZE));
  clearPreview();
  if(dx >= 0 && dx < SIZE && dy >= 0 && dy < SIZE) showPreview(dy - dragOffset.dy, dx - dragOffset.dx, hand[activeIdx]);
}

function handleEnd(e) {
  if(activeIdx === -1) return;
  const touch = e.changedTouches[0]; const rect = document.getElementById('board').getBoundingClientRect();
  const dx = Math.floor((touch.clientX - rect.left) / (rect.width / SIZE));
  const dy = Math.floor((touch.clientY - rect.top) / (rect.height / SIZE));
  if(placePiece(dy - dragOffset.dy, dx - dragOffset.dx, hand[activeIdx])) {
    playTone(660, 'sine', 0.1); hand[activeIdx] = null; dragEl.style.visibility = 'hidden';
    moveCount++; if(hand.every(h => h === null)) refillHand();
    checkBoard();
  }
  if(dragEl) { dragEl.style.transform = ''; dragEl.style.opacity = '1'; }
  clearPreview(); activeIdx = -1; render(); updateUI();
}

function clearPreview() { document.querySelectorAll('.preview').forEach(p => p.remove()); }
function showPreview(by, bx, piece) {
  if(!canPlace(by, bx, piece)) return;
  piece.shape.forEach((s, i) => {
    const cell = document.getElementById(`cell-${by+s[0]}-${bx+s[1]}`);
    if(cell) { const p = document.createElement('div'); p.className = `preview color-${piece.colors[i]}`; cell.appendChild(p); }
  });
}
function canPlace(by, bx, piece) {
  return piece.shape.every(s => {
    const ny = by + s[0], nx = bx + s[1];
    return ny >= 0 && ny < SIZE && nx >= 0 && nx < SIZE && board[ny][nx] === 0;
  });
}
function placePiece(by, bx, piece) {
  if(!canPlace(by, bx, piece)) return false;
  piece.shape.forEach((s, i) => { board[by+s[0]][bx+s[1]] = piece.colors[i]; });
  return true;
}

function checkBoard() {
  let lY = [], lX = [];
  for(let i=0; i<SIZE; i++) {
    if(board[i].every(v => v > 0)) lY.push(i);
    let full = true; for(let j=0; j<SIZE; j++) if(board[j][i] === 0) full = false;
    if(full) lX.push(i);
  }
  if(lY.length > 0 || lX.length > 0) {
    playTone(880, 'sine', 0.2);
    let targetCells = new Set();
    lY.forEach(y => { for(let x=0; x<SIZE; x++) targetCells.add(`${y},${x}`); });
    lX.forEach(x => { for(let y=0; y<SIZE; y++) targetCells.add(`${y},${x}`); });
    targetCells.forEach(coord => {
      const [y, x] = coord.split(',').map(Number); const c = board[y][x];
      if (counts[c] !== undefined && !clearedColors.has(c)) counts[c]++;
      board[y][x] = 0;
    });
    [2,3,4].forEach(c => {
      if(counts[c] >= normaTargets[c] && !clearedColors.has(c)) {
        clearedColors.add(c); playTone(1320, 'square', 0.3);
        for(let y=0; y<SIZE; y++) for(let x=0; x<SIZE; x++) if(board[y][x] === c) board[y][x] = 1;
        hand.forEach(p => { if(p) p.colors = p.colors.map(col => col === c ? 1 : col); });
      }
    });
  }
  if(clearedColors.size === 3) {
    gameOver = true; document.getElementById('clear-stats').innerText = `ã‚¯ãƒªã‚¢æ“ä½œå›æ•°: ${moveCount}å›`; document.getElementById('clearScreen').classList.add('show');
  } else if(!canPlaceAny()) {
    gameOver = true; document.getElementById('gameover').classList.add('show');
  }
}

function canPlaceAny() {
  return hand.some(p => {
    if(!p) return false;
    for(let y=0; y<SIZE; y++) for(let x=0; x<SIZE; x++) if(canPlace(y, x, p)) return true;
    return false;
  });
}

function render() {
  for(let y=0; y<SIZE; y++) for(let x=0; x<SIZE; x++) {
    const el = document.getElementById(`cell-${y}-${x}`); if(!el) continue;
    const v = board[y][x]; el.className = 'cell' + (v ? ` color-${v} filled` : '');
  }
}
function updateUI() {
  [2,3,4].forEach(c => { const el = document.getElementById(`c${c}`); if(el) el.innerText = `${counts[c]}/${normaTargets[c]}`; });
  document.getElementById('moveCount').innerText = moveCount;
}

// èª­ã¿è¾¼ã¿å®Œäº†å¾Œã«ç¢ºå®Ÿã«å®Ÿè¡Œ
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', init);
} else {
  init();
}
document.getElementById('resetBtn').onclick = init;
document.getElementById('restartBtn').onclick = init;
</script>
</body>
</html>